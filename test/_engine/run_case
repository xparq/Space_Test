#!/bin/sh

export TEST_DIR=${TEST_DIR:-`pwd`}
#echo Test dir is: \"$TEST_DIR\"
_TEST_ENGINE_DIR=`dirname $0`
export _TEST_ENGINE_DIR=`realpath ${_TEST_ENGINE_DIR}`

. _engine/defs.sh
retval=$?; if [[ "$retval" != "0" ]]; then exit $retval; fi

if ! case_path=`get_case_path $1`; then exit 1; fi    # `... exit $?` won't work, it's 0 by then! But why??

#!
#! Now we have a path to the test case (or ""!).
#! It can be either a single file or a test case dir.
#! This script must handle the differences.
#!

#! WOW!... Jesus FC!... :-/ Had to separate the `export` from setting it,
#! otherwise $? coming from the func. would be reset to 0! :-ooo
export CASE
if ! CASE=`get_case_name ${case_path}`; then exit 2; fi


echo "---------------------------------------------------------------"
DEBUG Identified \"$1\" as test case [$CASE] at \"$case_path\"
echo CASE \"${CASE}\"

if [[ ! -d  "${case_path}" ]]; then
	case_script="${case_path}"
	TEST_CASE_DIR=`dirname "${case_path}"`
else
	#!!Do better than hardcodings like this:
	case_script="${case_path}/case"
	TEST_CASE_DIR=${case_path}
fi

if [[ ! -e "${case_script}" ]]; then
	echo "- ERROR: test case script '${case_script}' not found!"
	return 1
fi

#
# Run a test case via a .case definition...
#

# Prep. the tmp work file locations...
#! Note: preparing the exp. results file usually requires running the case first (for its EXPECT clauses)!
outfile="${TMP_DIR}/${CASE}.out"
errfile="${TMP_DIR}/${CASE}.err"
retfile="${TMP_DIR}/${CASE}.retval"

# Reset the work files...
test -f "${outfile}" && rm "${outfile}"
test -f "${errfile}" && rm "${errfile}"
test -f "${retfile}" && rm "${retfile}"

#!!Move this to a function in defs:
# Run a build for the test case if it seems to need one... (and $MAKE is set)
MAKE=`check_make_flavor`

#!!the generic makefiles can't check *.cpp yet!
cpp=`find "${TEST_CASE_DIR}" -maxdepth 1 -name '*.cpp' -print -quit`
if [[ -n "${MAKE}" && -n "${cpp}" ]]; then
	a=`realpath "${TEST_CASE_DIR}"`
	b=`realpath "${TEST_DIR}"`
	#!!shuld be less dumb...:
	if [[ "$a" != "$b" ]]; then
		export DIR_OFFSET=../
	fi

	if [ "${MAKE}" == "nmake" ]; then
		#!BEWARE: /nologo, instead of -nologo, made Git-sh expand it to /full/path/nologo! :-o
		mkcmd="nmake -nologo"
		add_makefile="-f ${_TEST_ENGINE_DIR}/asset/TC-Makefile.nmake"
	else
		mkcmd="${MAKE}"
		add_makefile="-f ${_TEST_ENGINE_DIR}/asset/TC-Makefile.gmake"
	fi
	if [[ -e "${TEST_CASE_DIR}/Makefile.${MAKE}" ]]; then
		mkcmd="${mkcmd} -f Makefile.${MAKE}"
	elif [[ ! -e "${TEST_CASE_DIR}/Makefile" ]]; then   # <- only add if there's no local Makefile
		mkcmd="${mkcmd} ${add_makefile}"
	fi

	dirsave=`pwd`
	cd "${TEST_CASE_DIR}"
	${mkcmd}
	cd "${dirsave}"
fi

#-----------------------------------
# Finally, run (source) the case...
#-----------------------------------
failed=0
EXPECT=
case_variant_counter=0
. "${case_script}"

retval=$?; if [[ "$retval" != "0" ]]; then
	ERROR "Test script failed with unexpected error $retval!"
	exit 99
fi

# Find or dyn. regenerate the expfile if defined in a .case script
if [[ -e         "${TEST_CASE_DIR}/expect" ]]; then
	 expfile="${TEST_CASE_DIR}/expect"
# NOTE:
# In a mixed "GNU tools on Windows" env (like mine) diff may not be able
# to ignore CR/LF differences, so we need to strip those manually.
# (-> e.g.: https://github.com/skeeto/w64devkit/issues/45)
# One easy way is to normalize the newlines in *both* the output
# and the user-supplied "expect" file -- which means we'd need to
# "redirect" that too, the same way we do with an EXPECT clause.
# (Because obviously we won't touch the opriginal file.)
	kludge_expf="${TMP_DIR}/${CASE}.expected"
	# Better do this together with outfile, later below:
	# tr -d '\015' < ${expfile} > "${kludge_expf}"
	cp "${expfile}" "${kludge_expf}"
	expfile=${kludge_expf}
else
	expfile="${TMP_DIR}/${CASE}.expected"
	# $EXPECT must be quoted to preserve newlines.
	# And mind the -n, too:
	echo -n "${EXPECT}" > "${expfile}"
fi

# Normalizing these would prevent precision-testing some whitespace handling, but the
# CR/LF mismatches is a bigger issue anyway than what we could handle on this level...
normalize_crlf "${expfile}"
normalize_crlf "${outfile}"

#echo diff -b "${outfile}" "${expfile}"
     diff -b "${outfile}" "${expfile}"

if [[ $? == 0 ]]; then
	echo "  OK."
else
	echo "  !!!!!!!!!!!!!!!!!!!!!!!!! FAILED !!!!!!!!!!!!!!!!!!!!!!!!!"
	failed=1
fi

exit ${failed}
